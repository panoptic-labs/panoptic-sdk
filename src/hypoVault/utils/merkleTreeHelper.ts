// TODO: generated by claude. test against real solidity groundtruth
import { type Address, type Hex, encodePacked, keccak256 } from 'viem'

/**
 * Represents a leaf in the manage tree for authorization purposes
 */
export interface ManageLeaf {
  target: Address
  canSendValue: boolean
  signature: string
  argumentAddresses: Address[]
  description: string
  decoderAndSanitizer: Address
}

/**
 * Efficiently hashes two bytes32 values together
 * Equivalent to Solidity's keccak256(abi.encodePacked(a, b))
 */
function efficientHash(a: Hex, b: Hex): Hex {
  return keccak256(encodePacked(['bytes32', 'bytes32'], [a, b]))
}

/**
 * Hashes a pair of bytes32 values in sorted order (mimics OpenZeppelin's approach)
 * This ensures that hashPair(a, b) === hashPair(b, a)
 */
function hashPair(a: Hex, b: Hex): Hex {
  return a < b ? efficientHash(a, b) : efficientHash(b, a)
}

/**
 * Generates a Merkle proof for a given leaf within a Merkle tree
 * @param leaf The leaf hash to generate a proof for
 * @param tree The complete Merkle tree (array of layers, where tree[0] is the bottom layer)
 * @returns Array of sibling hashes that form the proof
 * @throws Error if the leaf is not found in the tree
 */
export function generateProof(leaf: Hex, tree: Hex[][]): Hex[] {
  // The length of each proof is the height of the tree - 1
  const treeLength = tree.length
  const proof: Hex[] = new Array(treeLength - 1)

  let currentLeaf = leaf

  // Build the proof by traversing up the tree
  for (let i = 0; i < treeLength - 1; i++) {
    const layer = tree[i]
    let found = false

    // Find the leaf in the current layer
    for (let j = 0; j < layer.length; j++) {
      if (currentLeaf === layer[j]) {
        // Found the leaf, determine if we need the next or previous sibling
        proof[i] = j % 2 === 0 ? layer[j + 1] : layer[j - 1]
        currentLeaf = hashPair(currentLeaf, proof[i])
        found = true
        break
      }
    }

    if (!found) {
      throw new Error('Leaf not found in tree')
    }
  }

  return proof
}

/**
 * Generates Merkle proofs for multiple manage leaves using a pre-built Merkle tree
 * @param manageLeafs Array of manage leaves to generate proofs for
 * @param tree The complete Merkle tree structure
 * @param rawDataDecoderAddress Address of the raw data decoder and sanitizer contract
 * @returns Array of proofs, one for each manage leaf
 */
export function getProofsUsingTree(
  manageLeafs: ManageLeaf[],
  tree: Hex[][],
  rawDataDecoderAddress: Address,
): Hex[][] {
  const proofs: Hex[][] = []

  for (let i = 0; i < manageLeafs.length; i++) {
    const manageLeaf = manageLeafs[i]

    // Generate the function selector (first 4 bytes of keccak256 hash of signature)
    const selectorHash = keccak256(encodePacked(['string'], [manageLeaf.signature]))
    const selector = selectorHash.slice(0, 10) as Hex // '0x' + 8 hex chars = 10 chars total

    // Build the raw digest by encoding packed:
    // rawDataDecoderAddress + target + canSendValue + selector + argumentAddresses
    let rawDigest = encodePacked(
      ['address', 'address', 'bool', 'bytes4'],
      [rawDataDecoderAddress, manageLeaf.target, manageLeaf.canSendValue, selector],
    )

    // Append each argument address to the raw digest
    for (const argAddress of manageLeaf.argumentAddresses) {
      rawDigest = encodePacked(['bytes', 'address'], [rawDigest, argAddress])
    }

    // Hash the raw digest to get the leaf
    const leaf = keccak256(rawDigest)

    // Generate and store the proof for this leaf
    proofs.push(generateProof(leaf, tree))
  }

  return proofs
}

/**
 * Generates Merkle proofs using pre-computed leaf digests
 * @param leafDigests Array of pre-computed leaf digest hashes
 * @param tree The complete Merkle tree structure (tree[0] is the leaf layer)
 * @returns Array of proofs, one for each leaf digest
 */
export function getProofsFromDigests(leafDigests: Hex[], tree: Hex[][]): Hex[][] {
  const proofs: Hex[][] = []

  for (const leafDigest of leafDigests) {
    proofs.push(generateProof(leafDigest, tree))
  }

  return proofs
}

/**
 * Converts a Merkle tree from JSON format to the expected format for proof generation
 * JSON format stores layers as: { "0": [root], "1": [...], "N": [leaves] }
 * Expected format: [[leaves], [...], [root]]
 * @param jsonTree The tree structure from JSON (keyed by layer index)
 * @returns Array of layers with leaves at index 0 and root at the end
 */
export function convertJsonTreeToArray(jsonTree: Record<string, readonly Hex[]>): Hex[][] {
  // Get the keys and sort them numerically to get layer indices
  const layerIndices = Object.keys(jsonTree)
    .map(Number)
    .sort((a, b) => a - b)

  // Reverse the order: JSON has [root, ..., leaves], we need [leaves, ..., root]
  const reversedIndices = [...layerIndices].reverse()

  return reversedIndices.map((index) => [...jsonTree[index.toString()]])
}
